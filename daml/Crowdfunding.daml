module Crowdfunding where

import DA.Map as Map
import DA.Set as Set
import DA.Time (time)
import DA.Optional (fromOptional)
import DA.List qualified as List
import Data

-- This represent a project to be funded
template CFProject
    with
        -- Owner (creator) of the project
        owner: Party
        -- Name of the project
        name: Text
        -- Deadline until contributors can contribute
        deadline: Date
        -- Minimum amount to launch the project
        threshold: Int
        -- List of confirmed contributors
        contributors: Map Party Int
        -- Parties that have been contacted to fund this project
        requested: [Party]

    where
        -- The owner only can create or archive this project
        signatory owner
        -- All contributors can observe this contract, alongside parties that were requested to contribute
        observer Set.fromList $ (fst <$> Map.toList contributors) <> requested 
        -- The key is the one of the project
        key ProjectKey{owner,name}: ProjectKey
        -- The owner of the project is the reference for key unicity
        maintainer key.owner
        -- Let's not have projects with empty names
        ensure name /= ""

        -- Checks for the current status of sent requests:
        -- If the request still exists, returns its ID
        -- If the request no longer exists, returns True if it was accepted, False otherwise
        -- This choice is non consuming as it is purely a request
        nonconsuming choice LiveRequests: [(Party, Either Bool (ContractId ContributionRequest))]
            controller owner
            do
                forA requested $ \target -> (target,) <$> do
                    let project = ProjectKey{owner,name}
                        lookupKey = ContributionRequestKey{target,project}
                    exists <- visibleByKey @ContributionRequest lookupKey
                    if exists then 
                        Right . fst <$> fetchByKey @ContributionRequest lookupKey
                    else 
                        return $ Left $ target `Map.member` contributors

        -- Checks for the current status of the project
        -- If the deadline is not yet reached, returns "InProgress"
        -- Otherwise, returns "Funded" or "Cancelled" depending on the threshold being reached
        nonconsuming choice GetCurrentStatus: ProjectStatus
            controller owner
            do
                currentTime <- getTime
                return $ if currentTime <= time deadline 23 59 59 then InProgress else
                    if List.foldl (\x -> (x +) . snd) 0 (Map.toList contributors) >= threshold then Funded else NotFunded

        -- This issues a contribution to the project. An initial contribution will require to receive a request
        -- after which it can be called at will to increase the contributed amount.
        choice Contribute: ContractId CFProject
            with
                contributor: Party
                amount: Int
            controller contributor
            do
                currentTime <- getTime
                assertMsg "Contributions must be strictly positive" $ amount > 0
                assertMsg "Contributions must be done before the deadline" $ currentTime <= time deadline 23 59 59
                assertMsg "This contribution was not requested" $ contributor `elem` requested

                create this with
                    contributors = Map.alter (Some . (+amount) . (fromOptional 0)) contributor contributors

        -- This lanches a project, giving coupons to contributors
        -- This is postconsuming, because we need to exercise "GetCurrentStatus" 
        -- before actually archiving the contract.
        postconsuming choice Launch: [ContractId Coupon]
            controller owner
            do
                currentStatus <- exercise self GetCurrentStatus
                assertMsg "Launching the project can only be done after the deadline" $ currentStatus /= InProgress

                let success = currentStatus == Funded
                    projectKey = ProjectKey{owner, name}

                forA (Map.toList contributors) $ \(contributor, amount) -> 
                    create Coupon{contributor, projectKey, amount, success}

        -- This creates contribution requests for the input list of parties
        choice SendRequests: (ContractId CFProject, [ContractId ContributionRequest])
            with 
                parties: [Party]
            controller owner
            do
                currentTime <- getTime

                assertMsg "Requests should be sent to separate peers." $ length parties == Set.size (Set.fromList parties)
                assertMsg "Contributors should not receive new requests" $ all (`notElem` requested) (fst <$> Map.toList contributors)
                assertMsg "Sending requests must be done before the deadline" $ currentTime <= time deadline 23 59 59
                assertMsg "You must send requests to at least 1 party." $ not $ Prelude.null parties

                projectCid <- create this with
                    requested = requested <> parties

                let projectKey = ProjectKey{owner,name}

                requestsCids <- forA parties $ \target -> 
                    create ContributionRequest{projectKey,target}

                return (projectCid, requestsCids)

-- This represents a coupon of participation in a project
template Coupon
    with 
        -- Owner of the coupon
        contributor: Party
        -- Project that was funded
        projectKey: ProjectKey
        -- Amount of the participation
        amount: Int
        -- Whether the project was successfully funded
        success: Bool

    where
        signatory projectKey.owner
        ensure projectKey.name /= ""

        choice Redeem: ()
            controller contributor
            do return ()

-- This represents a request by a project owner to a potential contributor
template ContributionRequest 
    with
        -- Project that sent this contribution request
        projectKey: ProjectKey
        -- The peer that was asked to fund the project
        target: Party

    where 
        signatory projectKey.owner
        observer target, projectKey.owner

        key ContributionRequestKey{target, project=projectKey}: ContributionRequestKey
        maintainer key.project.owner

        -- The party accepts to fund the project with a certain amount
        choice Accept: ContractId CFProject
            with
                amount: Int
            controller target
            do 
                refProject <- lookupByKey @CFProject projectKey
                case refProject of
                    None -> abort "This contribution request refers to a non-existing project."
                    Some projectId -> do
                        exercise projectId $ Contribute target amount

        choice Reject: ()
            controller target
            do
                return ()
